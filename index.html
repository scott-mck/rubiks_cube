<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Rubik's Cube</title>
		<meta charset="utf-8">
		<link rel=StyleSheet href="style.css" type="text/css" media=screen>
		<script src="./jquery-2.1.4.min.js"></script>
		<script src="./three.min.js"></script>
		<script src="http://mrdoob.github.com/three.js/examples/fonts/helvetiker_regular.typeface.js"></script>
		<script type="application/javascript" src="2D_cube.js"></script>
		<script type="application/javascript" src="3D_cube.js"></script>
		<script type="application/javascript" src="3D_event_handler.js"></script>
	</head>
	<body>
		<div id="what"></div>

		<div class="title">
			Rubik's Cube
		</div>

		<div id="sidebar">
			<div class="instructions">
				<span class="section">KEYBOARD</span>
				<p>i, k -- move right face</p>
				<p>f, j -- move up face</p>
				<p>e, d -- move left face</p>
				<p>s, l -- move down face</p>
				<p>g, h -- move front face</p>
				<p>q, p -- move back face</p>
				<p>a -- look left</p>
				<p>; -- look right</p>
				<p>y -- look down</p>
				<p>n -- look up</p>

				<br>

				<p>Space -- scramble</p>
				<p>Enter -- display solve moves</p>
			</div>

			<div class="scramble button">
				Scramble<br>
			</div>

			<div class="sample button">
				Example solve
			</div>

			<div class="timer">
				0.00
			</div>

			<div class="solve-moves"></div>
		</div>

		<!-- <div id="canvas"></div> -->

		<script>
			// TODO: Refactor init
			// TODO: Fade in cube
			var canvasWidth = $('#what').width();
			var canvasHeight = $('#what').height();

			var camera, scene, renderer;
			var mesh;
			var rubiksCube, eventHandler;
			var cubes = [];
			var solvedCubes = [];

			init();
			addEvents();
			animate();

			function init () {
				container = document.getElementById('what');
				document.body.appendChild(container);

				//setup scene
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( canvasWidth, canvasHeight );
				container.appendChild( renderer.domElement );
				camera = new THREE.PerspectiveCamera( 70, canvasWidth / canvasHeight, 1, 1000 );
				camera.position.z = 600;
				scene = new THREE.Scene();

				//Make individual cube geometry
        for (var j = 0; j < 9; j++) {
  				var geometry = new THREE.BoxGeometry( 100, 100, 100 );

					// Color each individual cube:
					// Color right face RED
					geometry.faces[0].color.setRGB(255/255,0/255,0/255);
					geometry.faces[1].color.setRGB(255/255,0/255,0/255);
					// Color left face ORANGE
					geometry.faces[2].color.setRGB(255/255,101/255,0/255);
					geometry.faces[3].color.setRGB(255/255,101/255,0/255);
					// Color top face YELLOW
					geometry.faces[4].color.setRGB(255/255,255/255,0/255);
					geometry.faces[5].color.setRGB(255/255,255/255,0/255);
					// Color down face WHITE
					geometry.faces[6].color.setRGB(255/255,255/255,255/255);
					geometry.faces[7].color.setRGB(255/255,255/255,255/255);
					// Color front face BLUE
					geometry.faces[8].color.setRGB(0/255,0/255,255/255);
					geometry.faces[9].color.setRGB(0/255,0/255,255/255);
					// Color back face GREEN
					geometry.faces[10].color.setRGB(0/255,255/255,0/255);
					geometry.faces[11].color.setRGB(0/255,255/255,0/255);

					// Create 3 mini-cubes and position along z-axis
					for (var k = 0; k < 3; k++) {
	          var material = new THREE.MeshBasicMaterial({ color: 0xffffff, vertexColors: THREE.FaceColors } );
	  				mesh = new THREE.Mesh( geometry, material );
	          mesh.position.set(103 -103 * ~~(j / 3), 103 -103 * (j % 3), 103 - 103 * k);

						// Create mini-cube border
						var helper = new THREE.EdgesHelper( mesh, 0x000000 );
						helper.material.linewidth = 10;

						cubes.push(mesh);
						solvedCubes.push(mesh);
						scene.add(helper);
						scene.add(mesh);
					}
        }

				camera.position.x += 250;
				camera.position.y += 300;
				camera.position.z -= 100;
				camera.lookAt(cubes[13].position); // look at middle of Rubik's Cube

				window.rubiksCube = new Game.Cube(scene, camera, cubes);
				eventHandler = new Game.EventHandler(rubiksCube, 'game');
			}

			function addEvents() {
				$('.scramble').on('click', function () {
					if ($('.scramble').hasClass('solve')) {
						$('.scramble').removeClass('solve');
						eventHandler.solve();
					} else {
						$('.scramble').addClass('solve');
						eventHandler.scramble();
					}
				});

				$('.sample').on('click', function () {
					eventHandler.solve();
					eventHandler.sampleSolve();
				});

				setInterval(function () {
					var colors = ['red', 'yellow', 'blue', 'green', 'orange', 'purple'];
					var i = ~~(Math.random() * colors.length);
					while (colors[i] === $('.title').css('color')) {
						i = ~~(Math.random() * colors.length);
					}
					$('.title').css('color', colors[i]);
				}, 5000);

				$(window).resize(onWindowResize);
			}

			function onWindowResize() {
				camera.aspect = $('#what').width() / $('#what').height();
				camera.updateProjectionMatrix();
				renderer.setSize($('#what').width(), $('#what').height());
			}

			function animate() {
				requestAnimationFrame( animate );
				renderer.render( scene, camera );
			}
		</script>
	</body>
</html>
