<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - cube</title>
		<meta charset="utf-8">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}
		</style>
		<link rel=StyleSheet href="style.css" type="text/css" media=screen>
		<script src="./jquery-2.1.4.min.js"></script>
		<script src="./three.min.js"></script>
		<script src="http://mrdoob.github.com/three.js/examples/fonts/helvetiker_regular.typeface.js"></script>
		<script type="application/javascript" src="2D_cube.js"></script>
		<script type="application/javascript" src="3D_cube.js"></script>
		<script type="application/javascript" src="3D_event_handler.js"></script>
	</head>
	<body>
		<h1 class="title begin">
			Rubik's Cube
		</h1>

		<h2>
			<small class="timer begin"></small>
		</h2>

		<div class="instructions begin">
			<h1>How to play:</h1>
			<p>
				MOUSE INSTRUCTIONS<br>
				Click on face and drag to move<br>
				Click off face and drag to rotate
			</p>
			<p>
				KEYBOARD INSTRUCTIONS<br>
				i, k: move right face<br>
				f, j: move up face<br>
				e, d: move left face<br>
				s, l: move down face<br>
				g, h: move front face<br>
				q, p: move back face<br>
				a: look left<br>
				semi-colon: look right<br>
				y: look down<br>
				n: look up<br>
				<br>
				Space: scramble<br>
				Enter: display solve moves<br>
			</p>
		</div>

		<h1 class="scramble begin">
			Click me to scramble!<br>
		</h1>

		<small class="solve-moves begin"></small>

		<div class="sample begin">
			Click me to see an example solve! (starts from a solved position)
		</div>

		<script>
			// TODO: Refactor init
			// TODO: Fade in cube
			var camera, scene, renderer;
			var mesh;
			var rubiksCube, eventHandler;
			var cubes = [];
			var solvedCubes = [];

			init();
			addEvents();
			animate();

			function init () {
				//setup scene
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 600;
				scene = new THREE.Scene();

				//Make individual cube geometry
        for (var j = 0; j < 9; j++) {
  				var geometry = new THREE.BoxGeometry( 100, 100, 100 );

					//Color each individual cube:
					//Color right face RED
					geometry.faces[0].color.setRGB(255/255,0/255,0/255);
					geometry.faces[1].color.setRGB(255/255,0/255,0/255);
					//Color left face ORANGE
					geometry.faces[2].color.setRGB(255/255,101/255,0/255);
					geometry.faces[3].color.setRGB(255/255,101/255,0/255);
					//Color top face YELLOW
					geometry.faces[4].color.setRGB(255/255,255/255,0/255);
					geometry.faces[5].color.setRGB(255/255,255/255,0/255);
					//Color down face WHITE
					geometry.faces[6].color.setRGB(255/255,255/255,255/255);
					geometry.faces[7].color.setRGB(255/255,255/255,255/255);
					//Color front face BLUE
					geometry.faces[8].color.setRGB(0/255,0/255,255/255);
					geometry.faces[9].color.setRGB(0/255,0/255,255/255);
					//Color back face GREEN
					geometry.faces[10].color.setRGB(0/255,255/255,0/255);
					geometry.faces[11].color.setRGB(0/255,255/255,0/255);

					//Create 3 mini-cubes and position along z-axis
					for (var k = 0; k < 3; k++) {
	          var material = new THREE.MeshBasicMaterial({ color: 0xffffff, vertexColors: THREE.FaceColors } );
	  				mesh = new THREE.Mesh( geometry, material );
	          mesh.position.set(103 -103 * ~~(j / 3), 103 -103 * (j % 3), 103 - 103 * k);

						//Create mini-cube border
						var helper = new THREE.EdgesHelper( mesh, 0x000000 );
						helper.material.linewidth = 10;

						cubes.push(mesh);
						solvedCubes.push(mesh);
						scene.add(helper);
						scene.add(mesh);
					}

        }

				camera.position.x += 250;
				camera.position.y += 300;
				camera.position.z -= 100;
				camera.lookAt(cubes[13].position); //look at middle of Rubik's Cube

				rubiksCube = new Game.Cube(scene, camera, cubes);
				eventHandler = new Game.EventHandler(rubiksCube, 'game');
			}

			function addEvents() {
				window.addEventListener( 'resize', onWindowResize, false );
				$('.instructions').removeClass('begin');
				$('.title').removeClass('begin');
				$('.scramble').removeClass('begin');
				$('.solve-moves').removeClass('begin');
				$('.timer').text('0.00');
				$('.timer').removeClass('begin');
				$('.sample').removeClass('begin');

				$('.scramble').on('click', function () {
					if ($('.scramble').hasClass('solve')) {
						eventHandler.solve();
					} else {
						$('.scramble').addClass('solve');
						eventHandler.scramble();
						$('.scramble').html('Click me to solve!');
					}
				});

				$('.sample').on('click', function () {
					eventHandler.solve.call(eventHandler);
					eventHandler.sampleSolve.call(eventHandler);
				});

				setInterval(function () {
					var colors = ['red', 'yellow', 'blue', 'green', 'orange', 'purple'];
					var i = ~~(Math.random() * colors.length);
					while (colors[i] === $('.title').css('color')) {
						i = ~~(Math.random() * colors.length);
					}
					$('.title').css('color', colors[i]);
				}, 5000);
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate );
				renderer.render( scene, camera );
			}
		</script>
	</body>
</html>
