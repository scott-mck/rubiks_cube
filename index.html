<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Rubik's Cube</title>
		<meta charset="utf-8">
		<link rel=StyleSheet href="style.css" type="text/css" media=screen>
		<script src="./jquery-2.1.4.min.js"></script>
		<script src="./three.min.js"></script>
		<script src="./threex.domevents.js"></script>
		<script src="http://mrdoob.github.com/three.js/examples/fonts/helvetiker_regular.typeface.js"></script>
		<script type="application/javascript" src="2D_cube.js"></script>
		<script type="application/javascript" src="3D_cube.js"></script>
		<script type="application/javascript" src="3D_event_handler.js"></script>
	</head>
	<body>
		<div id="canvas"></div>

		<div id="sidebar">
			<div class="title">
				Rubik's Cube
			</div>
			<div class="instructions">

				<div class="section">MOUSE INSTRUCTIONS</div>
				Click and Drag.

				<div class="section">KEYBOARD INSTRUCTIONS</div>
				<p>
					<div class="left">i, k</div>
					-- move right face
				</p>
				<p>
					<div class="left">f, j</div>
					-- move up face
				</p>
				<p>
					<div class="left">e, d</div>
					-- move left face
				</p>
				<p>
					<div class="left">s, l</div>
					-- move down face
				</p>
				<p>
					<div class="left">g, h</div>
					-- move front face
				</p>
				<p>
					<div class="left">q, p</div>
					-- move back face
				</p>
				<p>
					<div class="left">a</div>
					-- look left
				</p>
				<p>
					<div class="left">;</div>
					-- look right
				</p>
				<p>
					<div class="left">y</div>
					-- look down
				</p>
				<p>
					<div class="left">n</div>
					-- look up
				</p>

				<br>
				<p><div class="left">Space</div> -- scramble / solve</p>
				<p><div class="left">Enter</div> -- display solve moves</p>
			</div>

			<div class="scramble button">
				Scramble
			</div>

			<div class="sample button">
				Example solve
			</div>

			<div class="timer">
				0.00
			</div>

			<div class="solve-moves list"></div>
			<div class="undo-moves list"></div>
		</div>

		<script>
			// TODO: Refactor init
			// TODO: Fade in cube
			var canvasWidth = $('#canvas').width();
			var canvasHeight = $('#canvas').height();

			var camera, scene, renderer;
			// var mesh;
			var rubiksCube, eventHandler;
			var cubes = [];

			init();
			addEvents();
			animate();

			function init () {
				container = document.getElementById('canvas');
				document.body.appendChild(container);

				// Setup scene
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( canvasWidth, canvasHeight );
				container.appendChild( renderer.domElement );
				camera = new THREE.PerspectiveCamera( 70, canvasWidth / canvasHeight, 1, 1000 );
				camera.position.z = 600;
				scene = new THREE.Scene();

				// Make individual cube geometry
        for (var j = 0; j < 9; j++) {
  				var geometry = new THREE.BoxGeometry( 100, 100, 100 );

					// Color each individual cube:
					// Color right face RED
					geometry.faces[0].color.setRGB(255/255,0/255,0/255);
					geometry.faces[1].color.setRGB(255/255,0/255,0/255);
					// Color left face ORANGE
					geometry.faces[2].color.setRGB(255/255,101/255,0/255);
					geometry.faces[3].color.setRGB(255/255,101/255,0/255);
					// Color top face YELLOW
					geometry.faces[4].color.setRGB(255/255,255/255,0/255);
					geometry.faces[5].color.setRGB(255/255,255/255,0/255);
					// Color down face WHITE
					geometry.faces[6].color.setRGB(255/255,255/255,255/255);
					geometry.faces[7].color.setRGB(255/255,255/255,255/255);
					// Color front face BLUE
					geometry.faces[8].color.setRGB(0/255,0/255,255/255);
					geometry.faces[9].color.setRGB(0/255,0/255,255/255);
					// Color back face GREEN
					geometry.faces[10].color.setRGB(0/255,255/255,0/255);
					geometry.faces[11].color.setRGB(0/255,255/255,0/255);

					// Create 3 mini-cubes and position along z-axis
					for (var k = 0; k < 3; k++) {
	          var material = new THREE.MeshBasicMaterial({
							color: 0xffffff,
							vertexColors: THREE.FaceColors
						});

	  				var mesh = new THREE.Mesh(geometry, material);
	          mesh.position.set(
							103 -103 * ~~(j / 3),
							103 -103 * (j % 3),
							103 - 103 * k
						);

						// Create mini-cube border
						var helper = new THREE.EdgesHelper( mesh, 0x000000 );
						helper.material.linewidth = 7;

						cubes.push(mesh);
						scene.add(helper);
						scene.add(mesh);
					}
        }

				camera.position.x += 250;
				camera.position.y += 300;
				camera.position.z -= 100;
				camera.lookAt(cubes[13].position); // look at middle of Rubik's Cube

				window.rubiksCube = new Game.Cube(scene, camera, cubes);
				eventHandler = new Game.EventHandler(rubiksCube, 'game');
			}

			function addEvents() {
				$('.scramble').on('click', function () {
					if ($('.scramble').hasClass('solve')) {
						$('.scramble').removeClass('solve');
						eventHandler.solve();
					} else {
						$('.scramble').addClass('solve');
						eventHandler.scramble();
					}
				});

				$('.sample').on('click', function () {
					eventHandler.solve();
					eventHandler.sampleSolve();
				});

				$('.button').hover(function (event) {
					$(event.currentTarget).css('background', 'green');
				},
				function (event) {
					$(event.currentTarget).css('background', 'yellow');
				});

				$('.button').on('mousedown', function (event) {
					$(event.currentTarget).css('background', 'red');
				});

				$('.button').on('mouseup', function (event) {
					$(event.currentTarget).css('background', 'yellow');
				});

				setInterval(function () {
					var colors = ['red', 'yellow', 'blue', 'green', 'orange', 'purple'];
					var i = ~~(Math.random() * colors.length);
					while (colors[i] === $('.title').css('color')) {
						i = ~~(Math.random() * colors.length);
					}
					$('.title').css('color', colors[i]);
				}, 5000);

				$(window).resize(onWindowResize);
			}

			function onWindowResize() {
				camera.aspect = $('#canvas').width() / $('#canvas').height();
				camera.updateProjectionMatrix();
				renderer.setSize($('#canvas').width(), $('#canvas').height());
			}

			function animate() {
				requestAnimationFrame( animate );
				renderer.render( scene, camera );
			}
		</script>
	</body>
</html>
